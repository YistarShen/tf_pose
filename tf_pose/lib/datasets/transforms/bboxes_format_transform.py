
import tensorflow as tf
from tensorflow import Tensor, RaggedTensor
from typing import Dict, List, Optional, Tuple, Union
from lib.Registers import TRANSFORMS
#from  .base import CVBaseTransform


@TRANSFORMS.register_module()
class BBoxesFormatTransform:
    version = '1.0.2'
    r"""Randomly flip the image, bbox and keypoints.
    support multi bboxes in one image; it doesn't support batch img 
    
    Required Data's Keys:
        - bbox 

    Required Data's Values dtype:
        - tf.Tensor
    
        
    tensor = tf.ragged.constant([[[200.,300.,200.,300.], [200.,300.,200.,300.]], [[200.,300.,200.,300.]]])

    """
    def __init__(self,  convert_type: Optional[str]=None):
        
        self.convert_type = convert_type
        self.support_convert_type = [
            "cxcywh2yxyx","cxcywh2xyxy","cxcywh2xywh",
            "yxyx2cxcywh","yxyx2xyxy","yxyx2xywh",
            "xyxy2xywh","xyxy2yxyx","xyxy2cxcywh",
            "xywh2xyxy","xywh2yxyx","xywh2cxcywh"
        ]

    def __call__(self,data : Union[Dict,Tensor]) ->Union[Dict,Tensor]:
        """ it can fully support batched transform 
        1. only support dict[str, (tf.Tensor or tf.RaggedTensor) ] format
        2. if additional data keys will be generated by transform, 
           need to init new keys for data dict before dooing transform
        3. use image keys to verfiy whether data is batched
           non batch data : data['image'].shape.rank = 3
           batch data : data['image'].shape.rank = 4

        """

        if isinstance(data,dict):
            'dict'
            if data.get('bbox', None) is None:
                raise ValueError("data is dict type , "
                                "but cannot find required key : 'bbox' "
                )
            
            data['bbox'] = self.batched_transform(data['bbox'])
        elif isinstance(data,(Tensor,RaggedTensor)):
            'tensor'
            data = self.batched_transform(data) 
        else:
            raise TypeError(f"input data type must is dict, Tensor or RaggedTensor, "
                            f"but got {type(data)} @{self.__class__.__name__} "
            )

        return data

    def batched_transform(self, boxes : Tensor) -> Tensor:
        """The transform function of :class:`RandomFlip`.
        See ``transform()`` method of :class:`BaseTransform` for details.

        Args:
            data (dict):  The result dict
            i.e. data = {"image": img_tensor, "bbox":bbox_tensor, "kps": kps_tensor}
        Returns:
            dict: The output result dict. like input data
        """


        if  (self.convert_type=="cxcywh2yxyx"):
            '''
            cxcy,wh ->yx_min, yx_max
            [cx, cy]-[w, h]/2 = x_min, y_min
            [cx, cy]+[w, h]/2 = x_max, y_max
            '''
            boxes = tf.concat([boxes[..., :2] - boxes[..., 2:] / 2.0, boxes[..., :2] + boxes[..., 2:] / 2.0],axis=-1) #xy_min,xy_max
            boxes = tf.stack([boxes[..., 1], boxes[..., 0], boxes[..., 3], boxes[..., 2]], axis=-1) # yx_min, yx_max

        if  (self.convert_type=="cxcywh2xyxy"):
            '''
            cxcy,wh ->yx_min, yx_max
            [cx, cy]-[w, h]/2 = x_min, y_min
            [cx, cy]+[w, h]/2 = x_max, y_max
            '''          
            boxes = tf.concat([boxes[..., :2] - boxes[..., 2:] / 2.0, boxes[..., :2] + boxes[..., 2:] / 2.0],axis=-1) #xy_min,xy_max
        

        elif  (self.convert_type=="cxcywh2xywh"):
            """
            boxes : ( x_min, y_min, w, h )
            xy_min, wh -> cxcy,wh
            xy_min + wh /2 = cxcy
            boxes_output : ( cx, cy, w, h )
            """ 
            boxes = tf.concat([ (boxes[..., :2] - boxes[..., 2:]/2.0), boxes[..., 2:] ], axis=-1) #cxcy,wh  

        #------------src format is yxyx------------------------------------------------

        elif (self.convert_type=="yxyx2cxcywh"):
            '''
            yx_min, yx_max ->cxcy,wh
            ( yx_min + yx_max )/2 = cycx
            ( yx_max - yx_min )/2 = hw
            '''
            boxes = tf.concat([ (boxes[..., :2] + boxes[..., 2:])/2.0, (boxes[..., 2:] - boxes[..., :2]) ], axis=-1) #cycx,hw
            boxes = tf.stack([boxes[..., 1], boxes[..., 0], boxes[..., 3], boxes[..., 2]], axis=-1) # cxcy,wh

        elif (self.convert_type=="yxyx2xyxy"):
            '''
            yx_min, yx_max ->xy_min, xy_max 
            '''
            boxes = tf.stack([boxes[..., 1], boxes[..., 0], boxes[..., 3], boxes[..., 2]], axis=-1) # xyxy

        elif (self.convert_type=="yxyx2xywh"):
            '''
            yx_min, yx_max ->xy_min, xy_max 
            '''
            boxes = tf.stack([boxes[..., 1], boxes[..., 0], boxes[..., 3]-boxes[..., 1], boxes[..., 2]-boxes[..., 0]], axis=-1) # xyxy


        #------------src format is xyxy------------------------------------------------

        elif (self.convert_type=="xyxy2xywh"):
            """
            ( x_min, y_min, x_max, y_max) => ( x_min, y_min, w, h)
            """  
            boxes = tf.concat([boxes[..., :2] , boxes[..., 2:] - boxes[..., :2]],axis=-1) # xy_min,wh

        elif (self.convert_type=="xyxy2yxyx"):
            """
            ( x_min, y_min, x_max, y_max) => ( x_min, y_min, w, h)
            """  
            boxes = tf.stack([boxes[..., 1] , boxes[..., 0], boxes[..., 3] , boxes[..., 2]],axis=-1) # xy_min,wh

        elif (self.convert_type=="xyxy2cxcywh"):
            """
            ( x_min, y_min, x_max, y_max) => ( x_min, y_min, w, h)
            """  
            boxes = tf.concat([ (boxes[..., :2] + boxes[..., 2:])/2.0, (boxes[..., 2:] - boxes[..., :2]) ], axis=-1) #cycx,hw     

        #------------src format is xywh------------------------------------------------
        elif (self.convert_type=="xywh2xyxy"):
            """
            ( x_min, y_min, w, h ) => ( x_min, y_min, x_max, y_max)
            """
            boxes = tf.concat([boxes[..., :2], boxes[..., :2] + boxes[..., 2:]],axis=-1) #xy_min,xy_max

        elif (self.convert_type=="xywh2yxyx"):
            """
            ( x_min, y_min, w, h ) => ( x_min, y_min, x_max, y_max)
            """
            boxes = tf.concat([boxes[..., :2], boxes[..., :2] + boxes[..., 2:]],axis=-1) #xy_min,xy_max 
            boxes = tf.stack([boxes[..., 1] , boxes[..., 0], boxes[..., 3] , boxes[..., 2]],axis=-1) # xy_min,wh    

        elif  (self.convert_type=="xywh2cxcywh"):
            """
            boxes : ( x_min, y_min, w, h )
            xy_min, wh -> cxcy,wh
            xy_min + wh /2 = cxcy
            boxes_output : ( cx, cy, w, h )
            """ 
            boxes = tf.concat([ (boxes[..., :2] + boxes[..., 2:]/2.0), boxes[..., 2:] ], axis=-1) #cxcy,wh         
        
        else:
            raise RuntimeError(f'unknown conveter TYPE @bboxes_transform : "{self.convert_type}" '
                               f'please check support list { self.support_convert_type}  @{self.__class__.__name__}'
            )

        return boxes
    


    